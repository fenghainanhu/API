 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Linux cpuidle framework(1)_概述和软件架构</title>
<meta name="keywords" content="Linux 嵌入式 ARM RTOS Technology 享受 C语言,Linux,framework,cpuidle" />
<meta name="description" content="1. 前言  在计算机系统中，CPU的功能是执行程序，总结起来就是我们在教科书上学到的：取指、译码、执行。那么问题来了，如果没有程序要执行，CPU要怎么办？也许您会说，停掉就是了啊..." />
<meta name="generator" content="emlog" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.wowotech.net/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://www.wowotech.net/wlwmanifest.xml" />
<link rel="alternate" type="application/rss+xml" title="RSS"  href="http://www.wowotech.net/rss.php" />
<link href="http://www.wowotech.net/content/templates/default/main.css" rel="stylesheet" type="text/css" />
<link href="http://www.wowotech.net/admin/editor/plugins/code/prettify.css" rel="stylesheet" type="text/css" />
<script src="http://www.wowotech.net/admin/editor/plugins/code/prettify.js" type="text/javascript"></script>
<script src="http://www.wowotech.net/include/lib/js/common_tpl.js" type="text/javascript"></script>
<!--[if IE 6]>
<script src="http://www.wowotech.net/content/templates/default/iefix.js" type="text/javascript"></script>
<![endif]-->
</head>
<body>
<div id="wrap">
  <div id="header">
    <h1><a href="http://www.wowotech.net/">蜗窝科技</a></h1>
    <h3>慢下来，享受技术。</h3>
  </div>
    <div id="banner"><a href="http://www.wowotech.net/"><img src="http://www.wowotech.net/content/uploadfile/201401/top-1389777175.jpg" height="134" width="960" /></a></div>
    <div id="nav">	<ul class="bar">
			<li class="item common">
			<a href="http://www.wowotech.net/" >博客</a>
					</li>
			<li class="item common">
			<a href="http://www.wowotech.net/sort/project" >项目</a>
			            <ul class="sub-nav">
                <li><a href="http://www.wowotech.net/sort/x_project">X Project</a></li>			</ul>
            		</li>
			<li class="item common">
			<a href="http://www.wowotech.net/forum" target="_blank">讨论区</a>
					</li>
			<li class="item common">
			<a href="http://www.wowotech.net/about.html" >关于蜗窝</a>
					</li>
			<li class="item common">
			<a href="http://www.wowotech.net/contact_us.html" >联系我们</a>
					</li>
			<li class="item common">
			<a href="http://www.wowotech.net/support_us.html" >支持我们</a>
					</li>
			<li class="item common">
			<a href="http://www.wowotech.net/admin" >登录</a>
					</li>
		</ul>
</div>﻿<div id="content">
<div id="contentleft">
	<h2>Linux cpuidle framework(1)_概述和软件架构</h2>
	<p class="date">作者：<a href="http://www.wowotech.net/author/2" title=" runangaozhong@163.com">wowo</a> 发布于：2014-12-17 23:04 
			分类：<a href="http://www.wowotech.net/sort/pm_subsystem">电源管理子系统</a>
	 	</p>
	<h4>1. 前言</h4>  <p>在计算机系统中，CPU的功能是执行程序，总结起来就是我们在教科书上学到的：取指、译码、执行。那么问题来了，如果没有程序要执行，CPU要怎么办？也许您会说，停掉就是了啊。确实，是要停掉，但何时停、怎么停，却要仔细斟酌，因为实际的软硬件环境是非常复杂的。</p>  <p>我们回到Linux kernel上，Linux系统中，CPU被两类程序占用：一类是进程（或线程），也称进程上下文；另一类是各种中断、异常的处理程序，也称中断上下文。</p>  <p>进程的存在，是用来处理事务的，如读取用户输入并显示在屏幕上。而事务总有处理完的时候，如用户不再输入，也没有新的内容需要在屏幕上显示。此时这个进程就可以让出CPU，但会随时准备回来（如用户突然有按键动作）。同理，如果系统没有中断、异常事件，CPU就不会花时间在中断上下文。</p>  <p>在Linux kernel中，这种CPU的无所事事的状态，被称作idle状态，而cpuidle framework，就是为了管理这种状态。</p>  <p><font color="#0000ff">注：cpuidle framework系列文章会以ARM64作为示例平台，由于ARM64刚刚发布不久，较早版本的kernel没有相关的代码，因此选用了最新的</font><a href="https://www.kernel.org/pub/linux/kernel/v3.x/testing/linux-3.18-rc4.tar.xz"><u><font color="#0000ff">3.18-rc4</font></u></a><font color="#0000ff">版本的kernel。</font></p>  <h4>2. 功能概述</h4>  <p>曾经有过一段时间，Linux kernel的cpu idle框架是非常简单的，简单到driver工程师只需要在“include\asm-arm\arch-xxx\system.h”中定义一个名字为arch_idle的inline函数，并在该函数中调用kernel提供的cpu_do_idle接口，就Okay了，剩下的实现kernel全部帮我们做了，如下：</p>  <div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">   <div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet">     <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum1">   1:</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">inline</span> <span style="color: #0000ff">void</span> arch_idle(<span style="color: #0000ff">void</span>)</pre>
<!--CRLF-->

    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum2">   2:</span> {</pre>
<!--CRLF-->

    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum3">   3:</span>         cpu_do_idle();</pre>
<!--CRLF-->

    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum4">   4:</span> }</pre>
<!--CRLF--></div>
</div>

<blockquote>
  <p>以蜗蜗之前使用过的一个ARM926的单核CPU为例(内核版本为Linux2.6.23)，cpuidle的处理过程是： 
    <br />B start_kernel(arch\arm\kernel\head-common.S) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; start_kernel->rest_init(init\main.c) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff">;系统初始化完成后，将第一个进程（init）变为idle进程， 
      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ;以下都是在进程的循环中，周而复始…</font> 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpu_idle->default_idle(arch\arm\kernel\process.c) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; arch_idle(include\asm-arm\arch-xxx\system.h) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpu_do_idle(include/asm-arm/cpu-single.h) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpu_arm926_do_idle(arch/arm/mm/proc-arm926.S) 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; mcr&#160;&#160;&#160;&#160; p15, 0, r0, c7, c0, 4&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; @ Wait for interrupt&#160;&#160; <font color="#0000ff">;WFI指令</font> 

    <br /></p>
</blockquote>

<p><font style="background-color: #ffffff">虽然简单，却包含了idle处理的两个重点：</font></p>

<p>1）idle进程</p>

<p>idle进程的存在，是为了解决“何时idle”的问题。</p>

<p>我们知道，Linux系统运行的基础是进程调度，而所有进程都不再运行时，称作cpu idle。但是，怎么判断这种状态呢？kernel采用了一个比较简单的方法：在init进程（系统的第一个进程）完成初始化任务之后，将其转变为idle进程，由于该进程的优先级是最低的，所以当idle进程被调度到时，则说明系统的其它进程不再运行了，也即CPU idle了。最终，由idle进程调用idle指令（这里为WFI），让CPU进入idle状态。</p>

<p>“<a href="http://www.wowotech.net/armv8a_arch/wfe_wfi.html">ARM WFI和WFE指令</a>”中介绍过，WFI Wakeup events会把CPU从WFI状态唤醒，通常情况下，这些events是一些中断事件，因此CPU唤醒后会执行中断handler，在handler中会wakeup某些进程，在handler返回的时候进行调度，当没有其他进程需要调度执行的时候，调度器会恢复idle进程的执行，当然，idle进程不做什么，继续进入idle状态，等待下一次的wakeup。</p>

<p>2）WFI</p>

<p>WFI用于解决“怎么idle”的问题。</p>

<p>一般情况下，ARM CPU idle时，可以使用WFI指令，把CPU置为Wait for interrupt状态。该状态下，至少（和具体ARM core的实现有关，可参考“<a href="http://www.wowotech.net/armv8a_arch/wfe_wfi.html">ARM WFI和WFE指令</a>”）会把ARM core的clock关闭，以节省功耗。</p>

<p>也许您会觉得，上面的过程挺好了，为什么还要开发cpuide framework？蜗蜗的理解是：</p>

<blockquote>
  <p>ARM CPU的设计越来越复杂，对省电的要求也越来越苛刻，因而很多CPU会从<font color="#ff0000">“退出时的延迟”</font>和<font color="#ff0000">“idle状态下的功耗”</font>两个方面考虑，设计多种idle级别。对延迟较敏感的场合，可以使用低延迟、高功耗的idle；对延迟不敏感的场合，可以使用高延迟、低功耗的idle。</p>

  <p>而软件则需要根据应用场景，在恰当的时候，选择一个合适的idle状态。而选择的策略是什么，就不是那么简单了。这就是cpuidle framework的存在意义（我们可以根据下面cpuidle framework的软件架构，佐证这一点）。</p>
</blockquote>

<h4>3. 软件架构</h4>

<p>Linux kernel中，cpuidle framework位于“drivers/cpuidle”文件夹中，包含cpuidle core、cpuidle governors和cpuidle drivers三个模块，再结合位于kernel sched中的cpuidle entry，共同完成cpu的idle管理。软件架构如下图：<img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="cpuidle framework" border="0" alt="cpuidle framework" src="http://www.wowotech.net/content/uploadfile/201412/2e0daa969175b05f7038639a16df13fe20141217150419.gif" width="466" height="480" /></p>

<p>1）kernel schedule模块</p>

<p>位于kernel\sched\idle.c中，负责实现idle线程的通用入口（cpuidle entry）逻辑，包括idle模式的选择、idle的进入等等。</p>

<p>2）cpuidle core</p>

<p>cpuidle core负责实现cpuidle framework的整体框架，主要功能包括：</p>

<blockquote>
  <p>根据cpuidle的应用场景，抽象出cpuidle device、cpuidle driver、cpuidle governor三个实体；</p>

  <p>以函数调用的形式，向上层sched模块提供接口；</p>

  <p>以sysfs的形式，向用户空间提供接口；</p>

  <p>向下层的cpuidle drivers模块，提供统一的driver注册和管理接口；</p>

  <p>向下层的governors模块，提供统一的governor注册和管理接口。</p>
</blockquote>

<p>cpuidle core的代码主要包括：cpuidle.c、driver.c、governor.c、sysfs.c。</p>

<p>3）cpuidle drivers</p>

<p>负责idle机制的实现，即：如何进入idle状态，什么条件下会退出，等等。</p>

<p>不同的architecture、不同的CPU core，会有不同的cpuidle driver，平台驱动的开发者，可以在cpuidle core提供的框架之下，开发自己的cpuidle driver。代码主要包括：cpuidle-xxx.c。</p>

<p>4）cpuidle governors</p>

<p>Linux kernel的framework有两种比较固定的抽象模式：</p>

<blockquote>
  <p>模式1，provider/consumer模式，interrupt、clock、timer、regulator等大多数的framework是这种模式。它的特点是，这个硬件模块是为其它一个或多个模块服务的，因而framework需要从对上（consumer）和对下（provider）两个角度进行软件抽象；</p>

  <p>模式2，driver/governor模式，本文所描述的cpuidle framework即是这种模式。它的特点是：硬件（或者该硬件所对应的驱动软件）可以提供多种可选“方案”（这里即idle level），“方案”的实现（即机制），由driver负责，但是到底选择哪一种“方案”（即策略），则由另一个模块负责（即这里所说的governor）。</p>
</blockquote>

<p>模式2的解释可能有点抽象，把它放到cpuidle的场景里面，就很容易理解了：</p>

<p>前面讲过，很多CPU提供了多种idle级别（即上面所说的“方案”），这些idle 级别的主要区别是“idle时的功耗”和“退出时延迟”。cpuidle driver（机制）负责定义这些idle状态（每一个状态的功耗和延迟分别是多少），并实现进入和退出相关的操作。最终，cpuidle driver会把这些信息告诉governor，由governor根据具体的应用场景，决定要选用哪种idle状态（策略）。</p>

<p>kernel中，cpuidle governor都位于governors/目录下。</p>

<h4>4. 软件流程</h4>

<p>在阅读本章之前，还请读者先阅读如下三篇文章：</p>

<blockquote>
  <p>“<a href="http://www.wowotech.net/pm_subsystem/cpuidle_core.html">Linux cpuidle framework(2)_cpuidle core</a>”</p>

  <p>“<a href="http://www.wowotech.net/pm_subsystem/cpuidle_arm64.html">Linux cpuidle framework(3)_ARM64 generic CPU idle driver</a>”</p>

  <p>“<a href="http://www.wowotech.net/pm_subsystem/cpuidle_menu_governor.html">Linux cpuidle framework(4)_menu governor</a>”</p>
</blockquote>

<p>前面提到过，kernel会在系统启动完成后，在init进程（或线程）中，处理cpuidle相关的事情。大致的过程是这样的（kernel启动相关的分析，会在其它文章中详细介绍）：</p>

<blockquote>
  <p>首先需要说明的是，在SMP（多核）系统中，CPU启动的过程是：</p>

  <p>1）先启动主CPU，启动过程和传统的单核系统类似：stext-->start_kernel-->rest_init-->cpu_startup_entry</p>

  <p>2）启动其它CPU，可以有多种方式，例如CPU hotplug等，启动过程为：secondary_startup-->__secondary_switched-->secondary_start_kernel-->cpu_startup_entry</p>

  <p>上面的代码位于./arch/arm64/kernel/head.S、init/main.c等等，感兴趣的读者可以自行参考。最终都会殊途同归，运行至cpu_startup_entry接口，该接口位于kernel/sched/idle.c中，负责处理CPU idle的事情，流程如下（暂时忽略一些比较难理解的分支，如cpu idle poll等）。</p>
</blockquote>

<p>cpu_startup_entry流程：</p>

<blockquote>
  <p>cpu_startup_entry 
    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; arch_cpu_idle_prepare，进行idle前的准备工作，ARM64中没有实现 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpu_idle_loop，进入cpuidle的主循环 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 如果系统当前不需要调度（!need_resched()），执行后续的动作 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#ff0000">local_irq_disable，关闭irq中断</font> 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; arch_cpu_idle_enter，arch相关的cpuidle enter，ARM64中没有实现 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpuidle_idle_call，main idle function 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpuidle_select，通过cpuidle governor，选择一个cpuidle state 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpuidle_enter，通过cpuidle state，进入该idle状态 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; … 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#ff0000">中断产生，idle返回（注意，此时irq是被禁止的，因此CPU不能响应产生中断的事件）</font> 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cpuidle_reflect，通知cpuidle governor，更新状态 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#ff0000">local_irq_enable，使能中断，响应中断事件，跳转到对应的中断处理函数</font> 

    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; …&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; arch_cpu_idle_exit，和enter类似，ARM64没有实现 

    <br /></p>
</blockquote>

<p>具体的代码比较简单，不再分析了，但有一点，还需要着重说明一下：</p>

<p><font color="#0000ff">使用cpuidle framework进入idle状态时，本地irq是处于关闭的状态，因此从idle返回时，只能接着往下执行，直到irq被打开，才能执行相应的中断handler，这和之前传统的cpuidle不同。同时也间接证实了“</font><a href="http://www.wowotech.net/pm_subsystem/cpuidle_menu_governor.html"><font color="#0000ff">Linux cpuidle framework(4)_menu governor</font></a><font color="#0000ff">”中所提及的，为什么menu governor在reflect接口中只是简单的置一个标志。因为reflect是在关中断时被调用的，需要尽快返回，以便处理中断事件。</font></p>

<p>&#160;</p>

<p><em>原创文章，转发请注明出处。蜗窝科技</em>，<a href="http://www.wowotech.net/pm_subsystem/cpuidle_overview.html">www.wowotech.net</a>。</p>	<p class="tag">标签:	<a href="http://www.wowotech.net/tag/Linux">Linux</a>	<a href="http://www.wowotech.net/tag/framework">framework</a>	<a href="http://www.wowotech.net/tag/cpuidle">cpuidle</a></p>
		<a href="http://www.wowotech.net/support_us.html" style="display:block;text-align:center;">
		<img src="http://www.wowotech.net/content/uploadfile/201605/ef3e1463542768.png" align="middle" width="86" height="40"/>
	</a>
	<div class="nextlog">		&laquo; <a href="http://www.wowotech.net/pm_subsystem/hibernation.html">Linux电源管理(12)_Hibernate功能</a>
				|
				 <a href="http://www.wowotech.net/linux_kenrel/about_spin_lock.html">关于spin_lock的问题</a>&raquo;
	</div>
		<a name="comments"></a>
	<p class="comment-header"><b>评论：</b></p>
			<div class="comment" id="comment-3141">
		<a name="3141"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">zozowit</a> </b><br /><span class="comment-time">2015-11-26 11:11</span>
			<div class="comment-content">请问，“由于该进程的优先级是最低的，所以当idle进程被调度到时，则说明系统的其它进程不再运行了，也即CPU idle了”，这个进程的优先级是最低的，是在哪里有设置吗？</div>
			<div class="comment-reply"><a href="#comment-3141" onclick="commentReply(3141,this)">回复</a></div>
		</div>
			<div class="comment comment-children" id="comment-3165">
		<a name="3165"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-11-27 16:46</span>
			<div class="comment-content">@zozowit：抱歉，评论太多把您这个漏了……<br />Kernel调度器对idle thread有特殊照顾，具体可参考kernel/sched/core.c：<br />static void set_load_weight(struct task_struct *p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int prio = p-&gt;static_prio - MAX_RT_PRIO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct load_weight *load = &amp;p-&gt;se.load;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * SCHED_IDLE tasks get minimal weight:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (p-&gt;policy == SCHED_IDLE) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;inv_weight = WMULT_IDLEPRIO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;weight = scale_load(prio_to_weight[prio]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;inv_weight = prio_to_wmult[prio];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />}</div>
			<div class="comment-reply"><a href="#comment-3165" onclick="commentReply(3165,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-3181">
		<a name="3181"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">zozowit</a> </b><br /><span class="comment-time">2015-12-01 17:53</span>
			<div class="comment-content">@wowo：感谢解答，还有一点请您赐教，SCHED_IDLE是在哪里设定的？</div>
			<div class="comment-reply"><a href="#comment-3181" onclick="commentReply(3181,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-3182">
		<a name="3182"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-12-02 10:34</span>
			<div class="comment-content">@zozowit：抱歉，我为上面的回复以及文中的表述道歉，关于idle进程的优先级，应该是这样的（对进程管理的理解有限，可能还有错误）：<br />1. idle进程的优先级并不是最低的，实际上，它的用户优先级（user nice）是0，正常情况下，算得上系统中最高的了。<br />2. idle进程并不会参与调度，因此当无进程调度的时候执行idle进程，是调度器保证的，这一点并不依赖它的优先级。<br />3. idle进程的优先级怎么来的？<br />&nbsp;&nbsp;&nbsp;&nbsp;a）start_kernel后kernel执行的第一个进程，不是由do_fork动态生成的，而是静态定义的（也就是传说中的init_task），init_task的优先级为（include/linux/init_task.h）：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.prio&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = MAX_PRIO-20,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.static_prio&nbsp;&nbsp;&nbsp;&nbsp;= MAX_PRIO-20,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.normal_prio&nbsp;&nbsp;&nbsp;&nbsp;= MAX_PRIO-20, <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，全部是120，转换为user nice为0，user nice的范围是-20~19，值越大优先越低，因此init_task的优先级算是比较高的了。<br />&nbsp;&nbsp;&nbsp;&nbsp;b）随后的kernel运行过程中，都是在init_task的上下文中，最后init_task会变成boot cpu的idle线程，因此boot cpu的idle线程的优先级就继承了init_task的了。<br />&nbsp;&nbsp;&nbsp;&nbsp;c）对于其它CPU来说，执行如下操作（具体可参考”http://www.wowotech.net/pm_subsystem/cpu_hotplug.html“）：rest_init--&gt;kernel_init--&gt;kernel_init_freeable--&gt;smp_init—&gt;idle_threads_init—&gt;idle_init--&gt;fork_idle--&gt;copy_process--&gt;dup_task_struct(current)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程会两次task copy：第一次是在reset_init中，调用kernel_thread fork kernel_init线程；第二次是fork_idle时将current task copy到idle task中，因此，最终非boot cpu的idle task的优先级，也是继承自init_task。<br />4. 关于这个标记--SCHED_IDLE，现在kernel的调度器貌似没有使用的。<br /><br />进程管理的东西太复杂了，看着战战巍巍的，希望高手指正！也希望有高手把进程管理的东西给大家分析一下。</div>
			<div class="comment-reply"><a href="#comment-3182" onclick="commentReply(3182,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-3183">
		<a name="3183"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">zozowit</a> </b><br /><span class="comment-time">2015-12-02 10:43</span>
			<div class="comment-content">@wowo：您好，恕我愚笨。请问“ idle进程并不会参与调度，因此当无进程调度的时候执行idle进程，是调度器保证的”这个是否有代码可以阅读。另外之前您列出的代码，看上去确实是把这个优先级调低诶？<br /> /*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * SCHED_IDLE tasks get minimal weight:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (p-&gt;policy == SCHED_IDLE) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;load-&gt;inv_weight = WMULT_IDLEPRIO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
			<div class="comment-reply"><a href="#comment-3183" onclick="commentReply(3183,this)">回复</a></div>		</div>
			</div>
		<div class="comment comment-children" id="comment-3184">
		<a name="3184"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-12-02 10:52</span>
			<div class="comment-content">@zozowit：调度器的行为，我也没有细看，太复杂了。<br />我之前贴出的这一段代码，确实是这个逻辑，但我找了现在kernel的代码，没有发现哪个进程使用SCHED_IDLE这个policy，可能是kernel提供的一种方法吧，只是现在没有人用。</div>
			<div class="comment-reply"><a href="#comment-3184" onclick="commentReply(3184,this)">回复</a></div>		</div>
			</div>
		<div class="comment comment-children" id="comment-3185">
		<a name="3185"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">zozowit</a> </b><br /><span class="comment-time">2015-12-02 11:29</span>
			<div class="comment-content">@wowo：您好，我看了一下，是在start_kernel--&gt;init_idle中执行了rq-&gt;curr = rq-&gt;idle = idle<br />schedule函数中，按照rt ，cfs，idle这三种调度方式顺序，寻找各自的运行任务，那么如果rt和cfs都未找到运行任务，那么最后会调用idle schedule的idle进程，作为schedule函数调度的下一个任务。</div>
					</div>
			</div>
		<div class="comment comment-children" id="comment-3186">
		<a name="3186"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-12-02 11:42</span>
			<div class="comment-content">@zozowit：确实，idle作为一个单独的schedule class了，<br />const struct sched_class idle_sched_class<br />至于schedule class的含义，我就不了解了。</div>
			<div class="comment-reply"><a href="#comment-3186" onclick="commentReply(3186,this)">回复</a></div>		</div>
			</div>
		</div>
		</div>
		</div>
		</div>
		<div class="comment" id="comment-2845">
		<a name="2845"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">pingchangxin</a> </b><br /><span class="comment-time">2015-10-26 20:39</span>
			<div class="comment-content">请教一个问题，现在内核支持supend to RAM，这个流程会在pm.c中有***_pm_enter,里面有PM_SUSPEND_STANDY或者PM_SUPEND_MEM，而现在cpuidle，应该也可以在**_enter_idle里面可以根据此时的硬件状态，来做现在是WFI，还是进deep sleep，总感觉这两个有点重合，不知道，你理解的这两者是怎么结合起来的，谢谢！</div>
			<div class="comment-reply"><a href="#comment-2845" onclick="commentReply(2845,this)">回复</a></div>
		</div>
			<div class="comment comment-children" id="comment-2846">
		<a name="2846"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-10-26 20:49</span>
			<div class="comment-content">@pingchangxin：我的理解是：<br />STR和cpuidle，不是同一个事物，它们的目标不同，不具有可比性。<br />如果碰巧，它们通过相同的手段达到目的，这只是一个假象而已。<br />例如，系统进入STR状态时，就不会有idle的概念（idle线程被冻结了）。<br />所以，您的问题：怎么结合的？我觉得应该不会结合。</div>
			<div class="comment-reply"><a href="#comment-2846" onclick="commentReply(2846,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2856">
		<a name="2856"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">pingchangxin</a> </b><br /><span class="comment-time">2015-10-27 13:50</span>
			<div class="comment-content">@wowo：谢谢你，可能我被这个假象糊弄了，总觉得他们直接是不是有什么猫腻，呵呵</div>
			<div class="comment-reply"><a href="#comment-2856" onclick="commentReply(2856,this)">回复</a></div>		</div>
			</div>
		</div>
		</div>
		<div class="comment" id="comment-2792">
		<a name="2792"></a>
				<div class="comment-info">
			<b>cym </b><br /><span class="comment-time">2015-10-19 09:38</span>
			<div class="comment-content">hi wowo,每个cpu都有一个idle进程（或叫线程），他们的pid是一样的吗？或者叫做一个线程组更为合适？</div>
			<div class="comment-reply"><a href="#comment-2792" onclick="commentReply(2792,this)">回复</a></div>
		</div>
			<div class="comment comment-children" id="comment-2793">
		<a name="2793"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">linuxer</a> </b><br /><span class="comment-time">2015-10-19 10:37</span>
			<div class="comment-content">@cym：系统有多少个cpu core，就有多少个idle进程，BSP的idle进程的pid是0，其他的cpu的idle进程是在init进程（pid＝1）中初始化的，因此secondary cpu的idle进程和BSP 的idle进程的pid是不同的。</div>
			<div class="comment-reply"><a href="#comment-2793" onclick="commentReply(2793,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2794">
		<a name="2794"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-10-19 11:06</span>
			<div class="comment-content">@linuxer：关于CPU的idle线程的创建过程，可以参考“http://www.wowotech.net/pm_subsystem/cpu_hotplug.html”中有关的章节。<br /><br />idle thread的创建过程是：fork_idle--&gt;copy_process<br /><br />我对进程管理看的不多，不知道问题的答案（是，或者不是），但根据这个过程，我觉得所有的idle thread的pid应该是一个，即init_struct_pid。linuxer，是不是这样呢？</div>
			<div class="comment-reply"><a href="#comment-2794" onclick="commentReply(2794,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2796">
		<a name="2796"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">linuxer</a> </b><br /><span class="comment-time">2015-10-19 12:05</span>
			<div class="comment-content">@wowo：我也没有仔细看，我的直觉是觉得fork一个进程当然要分配一个pid了，要不还是等晚上有时间仔细看看代码好了</div>
			<div class="comment-reply"><a href="#comment-2796" onclick="commentReply(2796,this)">回复</a></div>		</div>
			</div>
		<div class="comment comment-children" id="comment-2797">
		<a name="2797"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">linuxer</a> </b><br /><span class="comment-time">2015-10-19 12:27</span>
			<div class="comment-content">@wowo：你说的是对的，我又看进去copy_process的代码，其中有一段：<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if (pid != &amp;init_struct_pid) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (IS_ERR(pid)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval = PTR_ERR(pid);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto bad_fork_cleanup_io;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />看起来如果是init_struct_pid就不再分配pid了。</div>
			<div class="comment-reply"><a href="#comment-2797" onclick="commentReply(2797,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2798">
		<a name="2798"></a>
				<div class="comment-info">
			<b>cym </b><br /><span class="comment-time">2015-10-19 13:50</span>
			<div class="comment-content">@linuxer：谢谢众大虾！</div>
			<div class="comment-reply"><a href="#comment-2798" onclick="commentReply(2798,this)">回复</a></div>		</div>
			</div>
		</div>
		</div>
		</div>
		</div>
		<div class="comment" id="comment-2511">
		<a name="2511"></a>
				<div class="comment-info">
			<b><a href="http://firoyang.org" target="_blank">firo</a> </b><br /><span class="comment-time">2015-08-30 20:01</span>
			<div class="comment-content">因而framework需要从对上（consumer）和对下（consumer）两个角度进行软件抽象；<br />两个consumer?</div>
			<div class="comment-reply"><a href="#comment-2511" onclick="commentReply(2511,this)">回复</a></div>
		</div>
			<div class="comment comment-children" id="comment-2513">
		<a name="2513"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-08-31 09:02</span>
			<div class="comment-content">@firo：抱歉，笔误，等下会改正，谢谢~~</div>
			<div class="comment-reply"><a href="#comment-2513" onclick="commentReply(2513,this)">回复</a></div>		</div>
			</div>
		</div>
		<div class="comment" id="comment-1265">
		<a name="1265"></a>
				<div class="comment-info">
			<b>tim </b><br /><span class="comment-time">2015-03-03 11:07</span>
			<div class="comment-content">如果 cpu 进入的 idle 状态是 WFI(C0 state)，则退出的流程是，先是 cpu 退出 WFI 状态，此时中断是被关闭的，所以不会响应中断，代码继续执行，当然执行的代码是 idle 线程，之后打开中断，执行中断处理函数。<br />如果 cpu 进入是其他状态(C1/C2 state)，退出时，则是 cpu 会重新上电，然后从 BROM 运行，之后是 mcpm_entry_point 函数 -&gt; cpu_resume 函数。此时 cpu 的上下文已经恢复，上下文还是之前的 idle 线程，之后的流程与 C0 类似。</div>
			<div class="comment-reply"><a href="#comment-1265" onclick="commentReply(1265,this)">回复</a></div>
		</div>
			</div>
		<div class="comment" id="comment-897">
		<a name="897"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">linuxer</a> </b><br /><span class="comment-time">2014-12-18 10:12</span>
			<div class="comment-content">有个问题探讨一下：<br />你文章中说到：“当任意事件把CPU从idle状态唤醒时，接着运行idle进程，idle进程会判断是否有其它进程需要运行，如果有则发起一次调度，将CPU让给其它进程。”<br /><br />当ARM处理器调用WFI指令进入idle状态的时候，可以唤醒它的至少应该包括下面的场景：<br />（1）来自其他处理器的SEV指令<br />（2）送达本处理器上的中断<br /><br />当是中断唤醒的场景的时候，是否应该立刻执行中断handler？难道还是要先运行idle进程？我猜想应该先执行中断handler，在handler中会wakeup某些进程，在handler返回的时候进行调度（而不是idle进程判断是否要有其他进程需要运行），当没有其他进程需要调度执行的时候，调度器会恢复idle进程的执行，当然，idle进程不做什么，继续进入idle状态，等待下一次的wakeup</div>
			<div class="comment-reply"><a href="#comment-897" onclick="commentReply(897,this)">回复</a></div>
		</div>
			<div class="comment comment-children" id="comment-898">
		<a name="898"></a>
				<div class="comment-info">
			<b>wowo </b><br /><span class="comment-time">2014-12-18 12:30</span>
			<div class="comment-content">@linuxer：传统的使用WFI的idle，确实应该是这样子啊，还是你总结的好，哈哈，等等我把这段话抄上去。<br />对于后面比较复杂的idle framework，是否会存在像suspend/resume那样的场景，可以在idle时suspend，然后返回时继续往下执行，这个还不太清楚，要往下继续看。<br /><br />PS：WFE才会有SEV指令，WFI没有。</div>
			<div class="comment-reply"><a href="#comment-898" onclick="commentReply(898,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-899">
		<a name="899"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">linuxer</a> </b><br /><span class="comment-time">2014-12-18 13:08</span>
			<div class="comment-content">@wowo：呵呵～～我看错了，WFE是用在spin lock中， 我刚才还想在idle的时候使用WFE怪怪的，原来是自己看错了。</div>
			<div class="comment-reply"><a href="#comment-899" onclick="commentReply(899,this)">回复</a></div>		</div>
			</div>
		</div>
		<div class="comment comment-children" id="comment-1113">
		<a name="1113"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-01-20 23:31</span>
			<div class="comment-content">@linuxer：我更新了这篇文章的最后一节，结果还真和我们想象的不一样，在cpuidle framework中，进入idle时，是关中断的，因此从idle回来后，只能先回到idle thread，打开中断后，才能执行中断handler。</div>
			<div class="comment-reply"><a href="#comment-1113" onclick="commentReply(1113,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2229">
		<a name="2229"></a>
				<div class="comment-info">
			<b>Y </b><br /><span class="comment-time">2015-07-15 22:54</span>
			<div class="comment-content">@wowo：从C1被中断唤醒后，是继续执行 enter(C1)的下一条指令,不需要软件参与吗？ 我看到楼上有兄弟说从BROM开始重新执行？ 到底哪个是对的 <br />thanks</div>
			<div class="comment-reply"><a href="#comment-2229" onclick="commentReply(2229,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2231">
		<a name="2231"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-07-16 08:44</span>
			<div class="comment-content">@Y：idle指令执行之后，CPU要做那些事情，idle回来之前，CPU要做哪些事情，都是和具体的平台有关的。不同平台，有不同的实现。<br />因此，回到您的问题，哪个都有可能是对的。这也是这篇文章没有涉及这部分内容的原因。<br />但有一点是可以保证的，对cpuidle framework本身，它“看到的”，是一致的，即：从哪里进去，就从哪里出来。</div>
			<div class="comment-reply"><a href="#comment-2231" onclick="commentReply(2231,this)">回复</a></div>		</div>
			</div>
		</div>
		<div class="comment comment-children" id="comment-2285">
		<a name="2285"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">shoujixiaodao</a> </b><br /><span class="comment-time">2015-07-22 11:12</span>
			<div class="comment-content">@wowo：进入idle时，是关中断的，因此从idle回来后，只能先回到idle thread，打开中断后，才能执行中断handler<br />&nbsp;&nbsp; ----有点小疑惑，既然关中断了。中断还能唤醒WFI状态吗？多谢！</div>
			<div class="comment-reply"><a href="#comment-2285" onclick="commentReply(2285,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2292">
		<a name="2292"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">wowo</a> </b><br /><span class="comment-time">2015-07-22 13:17</span>
			<div class="comment-content">@shoujixiaodao：可以的，具体可参考linuxer同学在这里的回复：http://www.wowotech.net/?post=81#2191</div>
			<div class="comment-reply"><a href="#comment-2292" onclick="commentReply(2292,this)">回复</a></div>		</div>
			<div class="comment comment-children" id="comment-2295">
		<a name="2295"></a>
				<div class="comment-info">
			<b><a href="http://www.wowotech.net/" target="_blank">shoujixiaodao</a> </b><br /><span class="comment-time">2015-07-22 13:48</span>
			<div class="comment-content">@wowo：学习力，涨姿势。多谢！</div>
			<div class="comment-reply"><a href="#comment-2295" onclick="commentReply(2295,this)">回复</a></div>		</div>
			</div>
		</div>
		</div>
		</div>
		</div>
	    <div id="pagenavi">
	        </div>
		<div id="comment-place">
	<div class="comment-post" id="comment-post">
		<div class="cancel-reply" id="cancel-reply" style="display:none"><a href="javascript:void(0);" onclick="cancelReply()">取消回复</a></div>
		<p class="comment-header"><b>发表评论：</b><a name="respond"></a></p>
		<form method="post" name="commentform" action="http://www.wowotech.net/index.php?action=addcom" id="commentform">
			<input type="hidden" name="gid" value="125" />
						<p>
				<input type="text" name="comname" maxlength="49" value="" size="22" tabindex="1">
				<label for="author"><small>昵称</small></label>
			</p>
			<p>
				<input type="text" name="commail"  maxlength="128"  value="" size="22" tabindex="2">
				<label for="email"><small>邮件地址 (选填)</small></label>
			</p>
			<p>
				<input type="text" name="comurl" maxlength="128"  value="" size="22" tabindex="3">
				<label for="url"><small>个人主页 (选填)</small></label>
			</p>
						<p><textarea name="comment" id="comment" rows="10" tabindex="4"></textarea></p>
			<p><img src="http://www.wowotech.net/include/lib/checkcode.php" align="absmiddle" /><input name="imgcode" type="text" class="input" size="5" tabindex="5" /> <input type="submit" id="comment_submit" value="发表评论" tabindex="6" /></p>
			<input type="hidden" name="pid" id="comment-pid" value="0" size="22" tabindex="1"/>
		</form>
	</div>
	</div>
		<div style="clear:both;"></div>
</div><!--end #contentleft-->
<ul id="sidebar">
	<li>
	<h3><span>站内搜索</span></h3>
	<ul>
	<script type="text/javascript">document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E%3Cscript charset="utf-8" src="http://znsv.baidu.com/customer_search/api/js?sid=16798210514584749375') + '&plate_url=' + (encodeURIComponent(window.location.href)) + '&t=' + (Math.ceil(new Date()/3600000)) + unescape('"%3E%3C/script%3E'));</script>	</ul>
	</li>
	<li>
	<h3><span>功能</span></h3>
	<ul>
	<a href="http://www.wowotech.net/message_board.html">留言板<br></a>
<a href="http://www.wowotech.net/?plugin=commentlist">评论列表<br></a>	</ul>
	</li>
	<li>
	<h3><span>随机文章</span></h3>
	<ul id="randlog">
		<li><a href="http://www.wowotech.net/pm_subsystem/cpufreq_core.html">linux cpufreq framework(3)_cpufreq core</a></li>
		<li><a href="http://www.wowotech.net/pm_subsystem/cpufreq_overview.html">linux cpufreq framework(1)_概述</a></li>
		<li><a href="http://www.wowotech.net/linux_kenrel/about_spin_lock.html">关于spin_lock的问题</a></li>
		<li><a href="http://www.wowotech.net/soft/debug_using_led.html">通过点亮LED的方法调试嵌入式代码</a></li>
		<li><a href="http://www.wowotech.net/pm_subsystem/clock_framework_core.html">Linux common clock framework(3)_实现逻辑分析</a></li>
		</ul>
	</li>
	<li>
	<h3><span>最新评论</span></h3>
	<ul id="newcomment">
		<li id="comment">simonzhang	<br /><a href="http://www.wowotech.net/device_model/dt-code-analysis.html#4135">感谢郭同学获益良多</a></li>
		<li id="comment">zcjfish	<br /><a href="http://www.wowotech.net/irq_subsystem/alloc_workqueue.html#4134">@zcjfish：修正下第二个问题：&nbsp;&nbsp;第二个问题是假设有4...</a></li>
		<li id="comment">zcjfish	<br /><a href="http://www.wowotech.net/irq_subsystem/alloc_workqueue.html#4133">现在的ARM core都有hotplug功能，就是说如果lo...</a></li>
		<li id="comment">zcjfish	<br /><a href="http://www.wowotech.net/irq_subsystem/gic_driver.html#4132">你好，请问PPI 中断的使用场景都有哪些？ 或者说什么样的中...</a></li>
		<li id="comment">XXX	<br /><a href="http://www.wowotech.net/gpio_subsystem/pin-controller-driver.html#4131">膜拜~</a></li>
		</ul>
	</li>
	<li>
	<h3><span>文章分类</span></h3>
	<ul id="blogsort">
		<li>
	<a href="http://www.wowotech.net/sort/linux_kenrel">Linux内核分析(10)</a>
	<a href="http://www.wowotech.net/rss.php?sort=4"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<ul>
				<li>
			<a href="http://www.wowotech.net/sort/device_model">统一设备模型(14)</a>
			<a href="http://www.wowotech.net/rss.php?sort=12"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/pm_subsystem">电源管理子系统(40)</a>
			<a href="http://www.wowotech.net/rss.php?sort=13"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/irq_subsystem">中断子系统(14)</a>
			<a href="http://www.wowotech.net/rss.php?sort=14"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/process_management">进程管理(5)</a>
			<a href="http://www.wowotech.net/rss.php?sort=15"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/kernel_synchronization">内核同步机制(17)</a>
			<a href="http://www.wowotech.net/rss.php?sort=16"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/gpio_subsystem">GPIO子系统(3)</a>
			<a href="http://www.wowotech.net/rss.php?sort=17"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/timer_subsystem">时间子系统(13)</a>
			<a href="http://www.wowotech.net/rss.php?sort=18"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/comm">通信类协议(4)</a>
			<a href="http://www.wowotech.net/rss.php?sort=20"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/memory_management">内存管理(5)</a>
			<a href="http://www.wowotech.net/rss.php?sort=21"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/graphic_subsystem">图形子系统(1)</a>
			<a href="http://www.wowotech.net/rss.php?sort=23"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/filesystem">文件系统(0)</a>
			<a href="http://www.wowotech.net/rss.php?sort=26"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				</ul>
			<li>
	<a href="http://www.wowotech.net/sort/u-boot">u-boot分析(2)</a>
	<a href="http://www.wowotech.net/rss.php?sort=25"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<li>
	<a href="http://www.wowotech.net/sort/linux_application">Linux应用技巧(11)</a>
	<a href="http://www.wowotech.net/rss.php?sort=3"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<li>
	<a href="http://www.wowotech.net/sort/soft">软件开发(6)</a>
	<a href="http://www.wowotech.net/rss.php?sort=1"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<li>
	<a href="http://www.wowotech.net/sort/basic_tech">基础技术(4)</a>
	<a href="http://www.wowotech.net/rss.php?sort=6"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<ul>
				<li>
			<a href="http://www.wowotech.net/sort/bluetooth">蓝牙(9)</a>
			<a href="http://www.wowotech.net/rss.php?sort=10"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/armv8a_arch">ARMv8A Arch(7)</a>
			<a href="http://www.wowotech.net/rss.php?sort=19"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				<li>
			<a href="http://www.wowotech.net/sort/display">显示(3)</a>
			<a href="http://www.wowotech.net/rss.php?sort=22"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				</ul>
			<li>
	<a href="http://www.wowotech.net/sort/basic_subject">基础学科(9)</a>
	<a href="http://www.wowotech.net/rss.php?sort=7"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<li>
	<a href="http://www.wowotech.net/sort/tech_discuss">技术漫谈(10)</a>
	<a href="http://www.wowotech.net/rss.php?sort=8"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<li>
	<a href="http://www.wowotech.net/sort/project">项目专区(0)</a>
	<a href="http://www.wowotech.net/rss.php?sort=9"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
			<ul>
				<li>
			<a href="http://www.wowotech.net/sort/x_project">X Project(5)</a>
			<a href="http://www.wowotech.net/rss.php?sort=24"><img src="http://www.wowotech.net/content/templates/default/images/rss.png" alt="订阅该分类"/></a>
		</li>
				</ul>
			</ul>
	</li>
	<li>
	<h3><span>文章存档</span></h3>
	<ul id="record">
		<li><a href="http://www.wowotech.net/record/201606">2016年6月(8)</a></li>
		<li><a href="http://www.wowotech.net/record/201605">2016年5月(8)</a></li>
		<li><a href="http://www.wowotech.net/record/201604">2016年4月(7)</a></li>
		<li><a href="http://www.wowotech.net/record/201603">2016年3月(5)</a></li>
		<li><a href="http://www.wowotech.net/record/201602">2016年2月(5)</a></li>
		<li><a href="http://www.wowotech.net/record/201601">2016年1月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201512">2015年12月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201511">2015年11月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201510">2015年10月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201509">2015年9月(4)</a></li>
		<li><a href="http://www.wowotech.net/record/201508">2015年8月(3)</a></li>
		<li><a href="http://www.wowotech.net/record/201507">2015年7月(7)</a></li>
		<li><a href="http://www.wowotech.net/record/201506">2015年6月(3)</a></li>
		<li><a href="http://www.wowotech.net/record/201505">2015年5月(7)</a></li>
		<li><a href="http://www.wowotech.net/record/201504">2015年4月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201503">2015年3月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201502">2015年2月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201501">2015年1月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201412">2014年12月(17)</a></li>
		<li><a href="http://www.wowotech.net/record/201411">2014年11月(8)</a></li>
		<li><a href="http://www.wowotech.net/record/201410">2014年10月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201409">2014年9月(7)</a></li>
		<li><a href="http://www.wowotech.net/record/201408">2014年8月(12)</a></li>
		<li><a href="http://www.wowotech.net/record/201407">2014年7月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201406">2014年6月(6)</a></li>
		<li><a href="http://www.wowotech.net/record/201405">2014年5月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201404">2014年4月(9)</a></li>
		<li><a href="http://www.wowotech.net/record/201403">2014年3月(7)</a></li>
		<li><a href="http://www.wowotech.net/record/201402">2014年2月(3)</a></li>
		<li><a href="http://www.wowotech.net/record/201401">2014年1月(4)</a></li>
		</ul>
	</li>
<div class="rss">
<a href="http://www.wowotech.net/rss.php" title="RSS订阅"><img src="http://www.wowotech.net/content/templates/default/images/rss.gif" alt="订阅Rss"/></a>
</div>
</ul><!--end #siderbar-->
</div><!--end #content-->
<div style="clear:both;"></div>
<div id="footerbar">
	Copyright @ 2013-2015 <a href="http://www.wowotech.net" title="wowotech">蜗窝科技</a> All rights reserved.
	Powered by <a href="http://www.emlog.net" title="采用emlog系统">emlog</a>
	<a href="http://www.miibeian.gov.cn" target="_blank"></a> <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9d3da49d9cb9a5eaca161fc2905551df";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>	</div><!--end #footerbar-->
</div><!--end #wrap-->
<script>prettyPrint();</script>
</body>
</html>